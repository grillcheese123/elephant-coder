{"ts": "2026-02-09T00:29:49Z", "session_id": "full_prompt_parity_20260209a_bugfix_04_elephant_r1", "role": "user", "command": "/code", "run_id": "run_6bbd13ec60ae", "content": "Fix OpenRouter retry logic so fatal auth errors do not retry and transient errors do."}
{"ts": "2026-02-09T00:29:49Z", "session_id": "full_prompt_parity_20260209a_bugfix_04_elephant_r1", "role": "assistant", "command": "/code", "run_id": "run_6bbd13ec60ae", "content": "```json\n{\n  \"summary\": \"The OpenRouter retry logic needs to distinguish between fatal authentication errors (e.g., 401/403) and transient errors (e.g., 429/5xx) to avoid unnecessary retries for auth failures. The current implementation in elephant_coder/openrouter_client.py raises OpenRouterError for all HTTP errors without differentiation. The CLI layer in scripts/elephant_cli.py already has helper functions (_is_retryable_model_error and _is_fatal_model_error) to classify errors, but they are not used in the OpenRouter client. The fix should move the retry decision into the client layer by adding retry logic that inspects the error message before retrying, or by exposing error classification in the client so the caller can decide.\",\n  \"project\": {\n    \"language\": \"python\"\n  },\n  \"files\": [\n    {\n      \"path\": \"elephant_coder/openrouter_client.py\",\n      \"content\": \"\\\"\\\"\\\"Minimal OpenRouter client for Elephant Coder.\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nimport json\\nimport time\\nfrom dataclasses import dataclass\\nfrom typing import Any\\nfrom urllib import error, request\\n\\n\\n@dataclass\\nclass OpenRouterResult:\\n    \\\"\\\"\\\"Normalized OpenRouter response.\\\"\\\"\\\"\\n\\n    content: str\\n    usage: dict[str, int]\\n    estimated_cost_usd: float\\n    raw: dict[str, Any]\\n\\n\\nclass OpenRouterError(RuntimeError):\\n    \\\"\\\"\\\"OpenRouter request error.\\\"\\\"\\\"\\n\\n\\ndef _is_retryable_error(message: str) -> bool:\\n    \\\"\\\"\\\"Determine if the error message indicates a transient error that should be retried.\\\"\\\"\\\"\\n    msg_lower = message.lower()\\n    # Transient errors: rate limits, server errors, timeouts\\n    if \\\"rate limit\\\" in msg_lower or \\\"quota exceeded\\\" in msg_lower:\\n        return True\\n    if \\\"timeout\\\" in msg_lower or \\\"timed out\\\" in msg_lower:\\n        return True\\n    if \\\"502\\\" in msg_lower or \\\"503\\\" in msg_lower or \\\"504\\\" in msg_lower:\\n        return True\\n    if \\\"connection refused\\\" in msg_lower or \\\"connection reset\\\" in msg_lower:\\n        return True\\n    return False\\n\\n\\ndef _is_fatal_error(message: str) -> bool:\\n    \\\"\\\"\\\"Determine if the error message indicates a fatal error that should not be retried.\\\"\\\"\\\"\\n    msg_lower = message.lower()\\n    # Fatal errors: authentication/authorization issues\\n    if \\\"unauthorized\\\" in msg_lower or \\\"forbidden\\\" in msg_lower:\\n        return True\\n    if \\\"invalid api key\\\" in msg_lower or \\\"invalid token\\\" in msg_lower:\\n        return True\\n    if \\\"401\\\" in msg_lower or \\\"403\\\" in msg_lower:\\n        return True\\n    return False\\n\\n\\nclass OpenRouterClient:\\n    \\\"\\\"\\\"HTTP client for OpenRouter chat completions.\\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        api_key: str,\\n        *,\\n        base_url: str = \\\"https://openrouter.ai/api/v1\\\",\\n        app_name: str = \\\"elephant-coder\\\",\\n        max_retries: int = 2,\\n        retry_backoff_sec: float = 1.0,\\n    ):\\n        if not api_key.strip():\\n            raise OpenRouterError(\\\"OPENROUTER_API_KEY is empty.\\\")\\n        self.api_key = api_key.strip()\\n        self.base_url = base_url.rstrip(\\\"/\\\")\\n        self.app_name = app_name\\n        self.max_retries = max_retries\\n        self.retry_backoff_sec = retry_backoff_sec\\n\\n    def chat_completion(\\n        self,\\n        *,\\n        model: str,\\n        messages: list[dict[str, str]],\\n        max_tokens: int,\\n        temperature: float = 0.2,\\n        timeout_sec: int = 60,\\n    ) -> OpenRouterResult:\\n        \\\"\\\"\\\"Send chat completion request with retry logic.\\\"\\\"\\\"\\n        last_error: Exception | None = None\\n        \\n        for attempt in range(self.max_retries + 1):\\n            payload = {\\n                \\\"model\\\": model,\\n                \\\"messages\\\": messages,\\n                \\\"max_tokens\\\": max_tokens,\\n                \\\"temperature\\\": temperature,\\n            }\\n            body = json.dumps(payload).encode(\\\"utf-8\\\")\\n            req = request.Request(\\n                f\\\"{self.base_url}/chat/completions\\\",\\n                method=\\\"POST\\\",\\n                data=body,\\n                headers={\\n                    \\\"Authorization\\\": f\\\"Bearer {self.api_key}\\\",\\n                    \\\"Content-Type\\\": \\\"application/json\\\",\\n                    \\\"HTTP-Referer\\\": \\\"https://github.com/grillcheese-ai/grilly\\\",\\n                    \\\"X-Title\\\": self.app_name,\\n                },\\n            )\\n            try:\\n                with request.urlopen(req, timeout=timeout_sec) as resp:\\n                    data = json.loads(resp.read().decode(\\\"utf-8\\\", errors=\\\"replace\\\"))\\n            except error.HTTPError as exc:\\n                raw = exc.read().decode(\\\"utf-8\\\", errors=\\\"replace\\\") if exc.fp else \\\"\\\"\\n                error_msg = f\\\"HTTP {exc.code}: {raw or exc.reason}\\\"\\n                \\n                # Check if this is a fatal error - do not retry\\n                if _is_fatal_error(error_msg):\\n                    raise OpenRouterError(error_msg) from exc\\n                \\n                # Check if this is a transient error - retry if attempts remain\\n                if _is_retryable_error(error_msg):\\n                    last_error = exc\\n                    if attempt < self.max_retries:\\n                        time.sleep(self.retry_backoff_sec * (2 ** attempt))  # exponential backoff\\n                        continue\\n                    raise OpenRouterError(error_msg) from exc\\n                \\n                # Other HTTP errors - do not retry\\n                raise OpenRouterError(error_msg) from exc\\n                \\n            except error.URLError as exc:\\n                error_msg = f\\\"Network error: {exc.reason}\\\"\\n                if _is_retryable_error(error_msg):\\n                    last_error = exc\\n                    if attempt < self.max_retries:\\n                        time.sleep(self.retry_backoff_sec * (2 ** attempt))\\n                        continue\\n                    raise OpenRouterError(error_msg) from exc\\n                raise OpenRouterError(error_msg) from exc\\n                \\n            except TimeoutError as exc:\\n                error_msg = \\\"OpenRouter request timed out.\\\"\\n                if _is_retryable_error(error_msg):\\n                    last_error = exc\\n                    if attempt < self.max_retries:\\n                        time.sleep(self.retry_backoff_sec * (2 ** attempt))\\n                        continue\\n                    raise OpenRouterError(error_msg) from exc\\n                raise OpenRouterError(error_msg) from exc\\n\\n            choices = data.get(\\\"choices\\\") or []\\n            if not choices:\\n                raise OpenRouterError(\\\"No choices returned from OpenRouter.\\\")\\n\\n            message = choices[0].get(\\\"message\\\") or {}\\n            content = str(message.get(\\\"content\\\") or \"\").strip()\\n\\n            usage_raw = data.get(\\\"usage\\\") or {}\\n            usage = {\\n                \\\"prompt_tokens\\\": int(usage_raw.get(\\\"prompt_tokens\\\", 0) or 0),\\n                \\\"completion_tokens\\\": int(usage_raw.get(\\\"completion_tokens\\\", 0) or 0),\\n                \\\"total_tokens\\\": int(usage_raw.get(\\\"total_tokens\\\", 0) or 0),\\n            }\\n            if usage[\\\"total_tokens\\\"] == 0:\\n                usage[\\\"total_tokens\\\"] = usage[\\\"prompt_tokens\\\"] + usage[\\\"completion_tokens\\\"]\\n\\n            estimated_cost_usd = 0.0\\n            for key in (\\\"cost\\\", \\\"total_cost\\\", \\\"estimated_cost\\\"):\\n                val = usage_raw.get(key)\\n                if val is not None:\\n                    try:\\n                        estimated_cost_usd = float(val)\\n                    except (TypeError, ValueError):\\n                        pass\\n\\n            return OpenRouterResult(\\n                content=content,\\n                usage=usage,\\n                estimated_cost_usd=estimated_cost_usd,\\n                raw=data,\\n            )\\n        \\n        # Should not reach here, but just in case\\n        if last_error is not None:\\n            raise OpenRouterError(str(last_error)) from last_error\\n        raise OpenRouterError(\\\"Unexpected error in OpenRouter client\\\")\\n\"\n    }\n  ],\n  \"dependencies\": {\n    \"dependencies\": {},\n    \"devDependencies\": {}\n  },\n  \"commands\": []\n}\n```"}
