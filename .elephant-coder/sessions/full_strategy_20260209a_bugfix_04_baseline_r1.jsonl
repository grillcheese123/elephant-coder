{"ts": "2026-02-09T00:19:25Z", "session_id": "full_strategy_20260209a_bugfix_04_baseline_r1", "role": "user", "command": "/code", "run_id": "run_8a325846d103", "content": "Fix OpenRouter retry logic so fatal auth errors do not retry and transient errors do."}
{"ts": "2026-02-09T00:19:25Z", "session_id": "full_strategy_20260209a_bugfix_04_baseline_r1", "role": "assistant", "command": "/code", "run_id": "run_8a325846d103", "content": "```json\n{\n  \"summary\": \"The OpenRouter retry logic in elephant_coder/openrouter_client.py lacks explicit handling to distinguish between fatal authentication errors (e.g., HTTP 401/403) and transient errors (e.g., HTTP 5xx, timeouts). The current implementation raises OpenRouterError for all HTTP errors without retry logic. The CLI layer in scripts/elephant_cli.py has helper functions (_is_retryable_model_error, _is_fatal_model_error) but they are not used in the OpenRouterClient. The fix should implement retry logic in OpenRouterClient that skips retries for fatal auth errors and retries transient errors.\",\n  \"project\": {\n    \"language\": \"python\"\n  },\n  \"files\": [\n    {\n      \"path\": \"elephant_coder/openrouter_client.py\",\n      \"content\": \"\\\"\\\"\\\"Minimal OpenRouter client for Elephant Coder.\\\"\\\"\\\"\\n\\nfrom __future__ import annotations\\n\\nimport json\\nimport time\\nfrom dataclasses import dataclass\\nfrom typing import Any\\nfrom urllib import error, request\\n\\n\\n@dataclass\\nclass OpenRouterResult:\\n    \\\"\\\"\\\"Normalized OpenRouter response.\\\"\\\"\\\"\\n\\n    content: str\\n    usage: dict[str, int]\\n    estimated_cost_usd: float\\n    raw: dict[str, Any]\\n\\n\\nclass OpenRouterError(RuntimeError):\\n    \\\"\\\"\\\"OpenRouter request error.\\\"\\\"\\\"\\n\\n\\nclass OpenRouterClient:\\n    \\\"\\\"\\\"HTTP client for OpenRouter chat completions.\\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        api_key: str,\\n        *,\\n        base_url: str = \\\"https://openrouter.ai/api/v1\\\",\\n        app_name: str = \\\"elephant-coder\\\",\\n    ):\\n        if not api_key.strip():\\n            raise OpenRouterError(\\\"OPENROUTER_API_KEY is empty.\\\")\\n        self.api_key = api_key.strip()\\n        self.base_url = base_url.rstrip(\\\"/\\\")\\n        self.app_name = app_name\\n\\n    def chat_completion(\\n        self,\\n        *,\\n        model: str,\\n        messages: list[dict[str, str]],\\n        max_tokens: int,\\n        temperature: float = 0.2,\\n        timeout_sec: int = 60,\\n        max_retries: int = 2,\\n        retry_backoff_sec: float = 1.0,\\n    ) -> OpenRouterResult:\\n        \\\"\\\"\\\"Send chat completion request with retry logic.\\\"\\\"\\\"\\n        payload = {\\n            \\\"model\\\": model,\\n            \\\"messages\\\": messages,\\n            \\\"max_tokens\\\": max_tokens,\\n            \\\"temperature\\\": temperature,\\n        }\\n        body = json.dumps(payload).encode(\\\"utf-8\\\")\\n        \\n        last_error: Exception | None = None\\n        \\n        for attempt in range(max_retries + 1):\\n            req = request.Request(\\n                f\\\"{self.base_url}/chat/completions\\\",\\n                method=\\\"POST\\\",\\n                data=body,\\n                headers={\\n                    \\\"Authorization\\\": f\\\"Bearer {self.api_key}\\\",\\n                    \\\"Content-Type\\\": \\\"application/json\\\",\\n                    \\\"HTTP-Referer\\\": \\\"https://github.com/grillcheese-ai/grilly\\\",\\n                    \\\"X-Title\\\": self.app_name,\\n                },\\n            )\\n            try:\\n                with request.urlopen(req, timeout=timeout_sec) as resp:\\n                    data = json.loads(resp.read().decode(\\\"utf-8\\\", errors=\\\"replace\\\"))\\n            except error.HTTPError as exc:\\n                last_error = exc\\n                raw = exc.read().decode(\\\"utf-8\\\", errors=\\\"replace\\\") if exc.fp else \\\"\\\"\\n                \\n                # Check if this is a fatal auth error (401/403) - do not retry\\n                if exc.code in (401, 403):\\n                    raise OpenRouterError(f\\\"HTTP {exc.code}: {raw or exc.reason}\\\") from exc\\n                \\n                # For other HTTP errors, check if we have retries left\\n                if attempt >= max_retries:\\n                    raise OpenRouterError(f\\\"HTTP {exc.code}: {raw or exc.reason}\\\") from exc\\n                \\n                # Transient error - wait and retry\\n                time.sleep(retry_backoff_sec * (2 ** attempt))\\n                continue\\n            except error.URLError as exc:\\n                last_error = exc\\n                if attempt >= max_retries:\\n                    raise OpenRouterError(f\\\"Network error: {exc.reason}\\\") from exc\\n                time.sleep(retry_backoff_sec * (2 ** attempt))\\n                continue\\n            except TimeoutError as exc:\\n                last_error = exc\\n                if attempt >= max_retries:\\n                    raise OpenRouterError(\\\"OpenRouter request timed out.\\\") from exc\\n                time.sleep(retry_backoff_sec * (2 ** attempt))\\n                continue\\n\\n            choices = data.get(\\\"choices\\\") or []\\n            if not choices:\\n                raise OpenRouterError(\\\"No choices returned from OpenRouter.\\\")\\n\\n            message = choices[0].get(\\\"message\\\") or {}\\n            content = str(message.get(\\\"content\\\") or \\\"\\\").strip()\\n\\n            usage_raw = data.get(\\\"usage\\\") or {}\\n            usage = {\\n                \\\"prompt_tokens\\\": int(usage_raw.get(\\\"prompt_tokens\\\", 0) or 0),\\n                \\\"completion_tokens\\\": int(usage_raw.get(\\\"completion_tokens\\\", 0) or 0),\\n                \\\"total_tokens\\\": int(usage_raw.get(\\\"total_tokens\\\", 0) or 0),\\n            }\\n            if usage[\\\"total_tokens\\\"] == 0:\\n                usage[\\\"total_tokens\\\"] = usage[\\\"prompt_tokens\\\"] + usage[\\\"completion_tokens\\\"]\\n\\n            estimated_cost_usd = 0.0\\n            for key in (\\\"cost\\\", \\\"total_cost\\\", \\\"estimated_cost\\\"):\\n                val = usage_raw.get(key)\\n                if val is not None:\\n                    try:\\n                        estimated_cost_usd = float(val)\\n                    except (TypeError, ValueError):\\n                        pass\\n                    break\\n\\n            return OpenRouterResult(\\n                content=content,\\n                usage=usage,\\n                estimated_cost_usd=estimated_cost_usd,\\n                raw=data,\\n            )\\n        \\n        # Should not reach here, but handle edge case\\n        if last_error:\\n            raise last_error\\n        raise OpenRouterError(\\\"Unexpected retry loop termination\\\")\\n\"\n    }\n  ],\n  \"dependencies\": {\n    \"dependencies\": {},\n    \"devDependencies\": {},\n    \"python\": [],\n    \"pythonDev\": [],\n    \"rust\": [],\n    \"go\": [],\n    \"cpp\": []\n  },\n  \"commands\": []\n}\n```"}
